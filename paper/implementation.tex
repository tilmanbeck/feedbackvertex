\chapter{Implementierung}
\label{c:impl}

\section{Nice Tree Decomposition}
\label{sec:impl_ntd}
Es wurde ein Algorithmus entwickelt, der als Eingabe eine standardmäßige Nice Tree Decomposition $\mathbb{T}$ eines Graphen $G$ erhält und eine Nice Tree Decomposition (siehe Kapitel \ref{sec:impl_ntd}) ausgibt. 
Da der Fokus dieser Arbeit auf der Implementierung des dynamischen Programms des Cut \& Count-Algorithmus liegt, wurde der Algorithmus nicht hinsichtlich der in \cite{kloks1994} beschriebenen polynomiellen Laufzeit optimiert. 

Der Algorithmus iteriert mehrmals in symmetrischer Reihenfolge (ausgehend von der Wurzel linksseitig absteigend) über $\mathbb{T}$ und fügt dabei die fehlenden Knoten ein. 
Hierbei sollte erwähnt werden, dass die Implementierung mit Ausnahme des \glqq Join\grqq -Bags neue Knoten stets linksseitig an den Elternknoten angehängt werden. 
Dies ist für die rekursive Iteration in Sektion \ref{sec:impl_dynP} wichtig.

Zu Beginn werden am bisherigen Wurzelknoten so lange \glqq Forget\grqq -Knoten angehängt bis noch ein Knoten des Ursprungsgraphen im Bag verbleibt. Anschließend wird ein letzter Knoten mit leerem Bag als neuer Wurzelknoten hinzugefügt. 
Ähnlich wird hinsichtlich der Blattknoten verfahren. 
Entsprechend der Differenz eines leeren Bags und der Bags der bisherigen Blattknoten werden am Ende jedes Pfades neue \glqq Introduce-Vertex\grqq -Knoten und ein Knoten mit leerem Bag als neuer Blattknoten angehängt. 
Für bestehende \glqq Join\grqq -Knoten werden die Bags der beiden Kindknoten verglichen. 
Sofern sie nicht denselben Bag wie der \glqq Join\grqq -Knoten haben, werden neue Knoten (\glqq Forget\grqq , \glqq Introduce Vertex\grqq ) eingefügt, bis die Bags identisch mit dem Elternknoten sind. 
In der nächsten Iteration werden die Differenzen der Bags von Kind- und Elternknoten verglichen. 
Falls diese größer eins ist, werden entsprechend viele neue Knoten (\glqq Forget\grqq , \glqq Introduce Vertex\grqq ) eingeführt.
Zuletzt wird für jede Kante $e$ des Ursprungsgraphen $G$ über den Graphen iteriert. 
Beim ersten gemeinsamen Auftreten der Knoten der Kante $e$ innerhalb eines Bags, wird oberhalb des Knoten dieses Bags ein neuer \glqq Introduce Edge\grqq -Knoten eingeführt und mit den Knoten der Kante $e$ gekennzeichnet.

Nach diesen Modifikationen liegt der Graph in der Form einer Nice Tree Decomposition wie in Sektion \ref{sec:ntd_ntd} beschrieben vor und kann zur Berechnung des dynamischen Programms verwendet werden.

\section{Dynamisches Programm}
\label{sec:impl_dynP}
Die Berechnungsvorschrift des dynamischen Programms ist in Sektion \ref{c:cc_steiner} erläutert. 
Für die Implementierung wird vom Wurzelknoten ausgehend in symmetrischer Reihenfolge über die Nice Tree Decomposition $\mathbb{T}$ iteriert und für jeden Bag eine $k \times kN \times 3^{|B_x|}$ - Matrix berechnet, wobei die Größe der Lösung $k$ und $N$ als Inputparameter übergeben werden. 
Die erste Dimension $k$ beschreibt die Größe (Anzahl Knoten) der Lösungsmenge. 
Die zweite Dimension $kN$ steht für die Summe der Gewichte der Lösungsmenge. 
Obwohl die Gewichte zufällig einheitlich verteilt werden, kann im schlechtesten Fall jedem Knoten das Gewicht $N$ zugewiesen werden. 
Daher kann die Gesamtsumme der Gewichte $W$ gleich $kN$ sein.
$3^{|B_x|}$ beschreibt die Anzahl der möglichen Färbungen innerhalb eines Bags. 
Während $k,N$ festgelegt sind, kann die Länge der Farb-Dimension $3^{|B_x|}$ von Bag zu Bag variieren. 

Da das dynamische Programm des Cut \& Count-Algorithmus die Berechnungsvorschrift für einen Bag rekursiv über den Bag des jeweiligen Kind-Knotens definiert, steigt der Algorithmus zu Beginn in $\mathbb{T}$ rekursiv ab bis er an einem Blattknoten angekommen ist. 
Für diesen gibt es keine Farb-Dimension (der Bag ist leer) und die $k \times kN$-Matrix wird initialisiert. 
Anschließend wird beim rekursiven Aufstieg für jeden Bag die entsprechende Berechnungsvorschrift angewendet und eine neue Datenmatrix berechnet. 

Im Falle eines \glqq Introduce Vertex\grqq -Bag werden für jede Färbung des Bags des Kindknotens drei neue Färbungen hinzugefügt.
Für einen \glqq Forget\grqq -Bag werden jeweils drei Färbungen des Bags des Kindknotens zu einer Färbung zusammengeführt.
Für alle anderen Bag-Typen bleibt die Länge der Farb-Dimension gleich, es werden jedoch nur Werte übernommen, welche die in Sektion \ref{sec:dynP} definierten Bedingungen erfüllen. 
Der \glqq Join\grqq -Bag nimmt eine Sonderstellung ein, da er als einziger zwei Kindknoten besitzt und im Algorithmus auf die Daten beider Bags zugreift. 
Die rekursive Berechnung in symmetrischer Reihenfolge gewährleistet, dass beide Kindknoten eines \glqq Join\grqq -Bags vorher berechnet werden. 
Der letzte Berechnungsschritt für den Wurzelknoten entspricht der Berechnung eines \glqq Forget\grqq -Knoten und führt die letzten drei Färbungen zusammen, so dass der Wurzelknoten (mit leerem Bag) eine $k \times kN$-Datenmatrix enthält. 
Diese kann für die Abfrage der Lösungen $A_r(k,W,\emptyset)$ genutzt werden.

Im Folgenden wird mithilfe von Pseudocode der grobe Aufbau des Algorithmus verdeutlicht und an einigen Stellen wichtige Implementierungsdetails vertieft.

\begin{svgraybox}
\begin{lstlisting}[language=python]
def countC(node, indices, data, k, N, terminals, weights):
    if node.linker_Knoten is not None:
        # steige linksseitig ab
    if node.rechter_Knoten is not None:
	# steige rechtsseitig ab
    if node.Bag_Typ == BagTyp.Leaf:
    	# erzeuge und initialisiere k x kN Datenmatrix
    elif node.Bag_Typ == BagTyp.Root:
	# im Root-Bag (v wurde aus Bag entfernt)
	for i in range(0,k):
		for w in range(0,kN):
			data[i,w,s] = child_data[i,w,s=0] + child_data[i,w,s=1] + child_data[i,w,s=2]
	return data			
    elif node.Bag_Typ == BagTyp.Introduce_Edge:
	# im 'Introduce Edge'-Bag (u,v sind die Knoten der Kante e)
		for s in Faerbungen
        mat_size = 3 ** len(node.get_bag())
        new_data = np.zeros((mat_size, k, (k-1)*N))
        first_vertex = node.get_label().pop()
        scnd_vertex = node.get_label().pop()
        pos_first_vertex = node.get_bag().index(first_vertex)
        pos_scnd_vertex = node.get_bag().index(scnd_vertex)
        for s in range(0, mat_size):
            coloring_from_index = ut.get_index_as_list(s, len(node.get_bag()))
            first_col = coloring_from_index[pos_first_vertex]
            scnd_col = coloring_from_index[pos_scnd_vertex]
            if first_col == 0 or scnd_col == 0 or first_col == scnd_col:
                for i in range(0, k):
                    for w in range(0, (k - 1) * N):
                        new_data[s, i, w] = data[s, i, w]
        # ut.write_to_file(outputFile, 'a', new_data, new_data.shape[0], str(node.bag_type) + str(node.get_bag()))
        return new_data

    elif node.bag_type == BagType.IV:

        # create new data matrix (one dimension bigger than child)
        new_data = np.zeros((3 ** len(node.get_bag()), k, (k - 1) * N))
        introduced_vertex = node.get_label()
        child_bag = node.get_left().get_bag()
        pos_iv = node.get_bag().index(introduced_vertex)
        # we have to iterate over all colorings from child bag
        length_child_colors = 3 ** len(child_bag)

        # okay from here we iterate over colorings (x), i (y) and the weights (z)
        # we simply assume that v_1 is the first terminal in the terminals array
        # if new vertex is colored 0
        for s in range(0, length_child_colors):
            coloring_from_index = ut.get_index_as_list(s, len(child_bag))
            # this is the special if the child bag is a leaf
            # and there is no coloring
            if node.get_left().get_bag_type() == BagType.L:
                ext_coloring = [pos_iv]
            else:
                ext_coloring = coloring_from_index[0:pos_iv] + [0] + coloring_from_index[pos_iv:]

            # need to sort as calculateIndices doesn't do it
            indices = sorted(ut.calculate_indices(ext_coloring, [pos_iv]))
            for i in range(0, k):
                for w in range(0, (k - 1) * N):
                    # write the three new matrices according to the rules from the paper
                    if not (terminals.__contains__(introduced_vertex)):
                        new_data[indices[0], i, w] = data[s, i, w]

                    if 0 <= i - 1 < k and (w - weights.get(introduced_vertex) >= 0) and (
                                    w - weights.get(introduced_vertex) < (k - 1) * N):
                        new_data[indices[1], i, w] = data[s, i - 1, w - weights.get(introduced_vertex)]
                    else:
                        new_data[indices[1], i, w] = 0

                    if (terminals[0] != introduced_vertex and (0 <= i - 1 < k) and 
                            w - weights.get(introduced_vertex) >= 0):
                        new_data[indices[2], i, w] = data[s, i - 1, w - weights.get(introduced_vertex)]
                    else:
                        new_data[indices[2], i, w] = 0
        # ut.write_to_file(outputFile, 'a', new_data, new_data.shape[0], str(node.bag_type) + str(node.get_bag()))
        return new_data

    elif node.bag_type == BagType.F:

        # create new matrix with size of bag (one dimension less than child)
        tmp = 3 ** len(node.get_bag())
        new_data = np.zeros((tmp, k, (k - 1) * N))

        # which position did forgotten vertex take in child bag
        fgt_vertex = node.get_label()
        child_bag = node.get_left().get_bag()
        old_pos = child_bag.index(fgt_vertex)

        for s in range(0, tmp):
            for i in range(0, k):
                for w in range(0, (k - 1) * N):
                    # get the int value of current coloring as list of ternary values
                    coloring = ut.get_index_as_list(s, len(node.get_bag()))
                    # add new position for forgotten bag (init as zero because calculateIndices requests that)
                    coloring = coloring[0:old_pos] + [0] + coloring[old_pos:]
                    # calculate the three indices to access in child data matrix
                    indices_to_sum = ut.calculate_indices(coloring, [old_pos])
                    # add the three matrices and write back to new matrix
                    new_data[s, i, w] = data[indices_to_sum[0], i, w] + data[indices_to_sum[1], i, w] +\
                                       data[indices_to_sum[2], i, w]
        # ut.write_to_file(outputFile, 'a', new_data, new_data.shape[0], str(node.bag_type) + str(node.get_bag()))
        return new_data

    elif node.bag_type == BagType.J:
        bag_size = len(node.get_bag())
        mat_size = 3 ** bag_size
        new_data = np.zeros((mat_size, k, (k-1)*N))
        colorings = ut.calculate_indices([0 for i in range(0, bag_size)], [i for i in range(0, bag_size)])
        for s in colorings:
            for i in range(0, k):
                for w in range(0, (k - 1) * N):
                    value = 0
                    # we use the these bounds to limit the iterations of the loops
                    # searching for the right i1 and i2 resp. w1 and w2
                    # we know i1+i2 = y + #(nodes with coloring 1 or 2)
                    # and w1+w2 = z + sum of the weights of the nodes with coloring 1 or 2
                    # acc_bound_1 refers to the bound in the paper for the 'i' index
                    # resp. acc_bound_2 to the bound in the paper for 'w' index
                    index_node_as_list = ut.get_index_as_list(s, bag_size)
                    colored_nodes = ut.get_nodes_by_coloring(index_node_as_list, [1, 2], indices)
                    acc_bound_1 = i + len(colored_nodes)
                    acc_bound_2 = w + ut.get_sum_of_weights(colored_nodes, weights)
                    for i1 in range(0, acc_bound_1):
                        for w1 in range(0, acc_bound_2):
                            i2 = acc_bound_1 - i1
                            w2 = acc_bound_2 - w1
                            if w1 >= ((k-1)*N) or w2 >= ((k-1)*N) or i1 >= k or i2 >= k:
                                value += 0
                            else:
                                value += (data[s, i1, w1] * data_right[s, i2, w2])
                    new_data[s, i, w] = value
        ut.write_to_file(outputFile, 'a', new_data, new_data.shape[0], str(node.bag_type) + str(node.get_bag()))
        return new_data
    return data
\end{lstlisting}
\end{svgraybox}
\section{Evaluierung}
\label{sec:eval}

\section{Ausblick}
\label{sec:outlook}
