\chapter{Implementierung}
\label{c:impl}

\section{Nice Tree Decomposition}
\label{sec:impl_ntd}
Es wurde ein Algorithmus entwickelt, der als Eingabe eine standardmäßige Nice Tree Decomposition $\mathbb{T}$ eines Graphen $G$ erhält und eine Nice Tree Decomposition (siehe Kapitel \ref{sec:ntd_ntd}) ausgibt. 
Da der Fokus dieser Arbeit auf der Implementierung des dynamischen Programms des Cut \& Count-Algorithmus liegt, wurde der Algorithmus nicht hinsichtlich der in \cite{kloks1994} beschriebenen polynomiellen Laufzeit optimiert. 

Der Algorithmus iteriert mehrmals in symmetrischer Reihenfolge (ausgehend von der Wurzel linksseitig absteigend) über $\mathbb{T}$ und fügt dabei die fehlenden Knoten ein. 
Hierbei sollte erwähnt werden, dass in unserer Implementierung mit Ausnahme des \glqq Join\grqq -Bags neue Knoten stets linksseitig an den Elternknoten angehängt werden. 
Dies ist für die rekursive Iteration in Sektion \ref{sec:impl_dynP} wichtig.

Zu Beginn werden am bisherigen Wurzelknoten so lange \glqq Forget\grqq -Knoten angehängt bis noch ein Knoten des Ursprungsgraphen im Bag verbleibt. 
Anschließend wird ein letzter Knoten mit leerem Bag als neuer Wurzelknoten hinzugefügt. 
Ähnlich wird hinsichtlich der Blattknoten verfahren. 
Entsprechend der Differenz eines leeren Bags und der Bags der bisherigen Blattknoten werden am Ende jedes Pfades neue \glqq Introduce-Vertex\grqq -Knoten und ein Knoten mit leerem Bag als neuer Blattknoten angehängt. 
Für bestehende \glqq Join\grqq -Knoten werden die Bags der beiden Kindknoten verglichen. 
Sofern sie nicht denselben Bag wie der \glqq Join\grqq -Knoten haben, werden neue Knoten (\glqq Forget\grqq , \glqq Introduce Vertex\grqq ) eingefügt, bis die Bags identisch mit dem Elternknoten sind. 
In der nächsten Iteration werden die Differenzen der Bags von Kind- und Elternknoten verglichen. 
Falls diese größer eins ist, werden entsprechend viele neue Knoten (\glqq Forget\grqq , \glqq Introduce Vertex\grqq ) eingeführt.
Zuletzt wird für jede Kante $e$ des Ursprungsgraphen $G$ über den Graphen iteriert. 
Beim ersten gemeinsamen Auftreten der Knoten der Kante $e$ innerhalb eines Bags, wird oberhalb des Knoten dieses Bags ein neuer \glqq Introduce Edge\grqq -Knoten eingeführt und mit den Knoten der Kante $e$ gekennzeichnet.

Nach diesen Modifikationen liegt der Graph in der Form einer Nice Tree Decomposition wie in Sektion \ref{sec:ntd_ntd} beschrieben vor und kann zur Berechnung des dynamischen Programms verwendet werden.

\section{Dynamisches Programm}
\label{sec:impl_dynP}
Die Berechnungsvorschrift des dynamischen Programms ist in Sektion \ref{c:cc_steiner} erläutert. 
Für die Implementierung wird vom Wurzelknoten ausgehend in symmetrischer Reihenfolge über die Nice Tree Decomposition $\mathbb{T}$ iteriert und für jeden Bag eine $k \times kN \times 3^{|B_x|}$ - Matrix berechnet, wobei die Größe der Lösung $k$ und $N$ als Inputparameter übergeben werden. 
Die erste Dimension $k$ beschreibt die Größe (Anzahl Knoten) der Lösungsmenge. 
Die zweite Dimension $kN$ steht für die Summe der Gewichte der Lösungsmenge. 
Obwohl die Gewichte zufällig einheitlich verteilt werden, kann im schlechtesten Fall jedem Knoten das Gewicht $N$ zugewiesen werden. 
Daher kann die Gesamtsumme der Gewichte $W$ gleich $kN$ sein.
$3^{|B_x|}$ beschreibt die Anzahl der möglichen Färbungen innerhalb eines Bags. 
Während $k,N$ festgelegt sind, kann die Länge der Farb-Dimension $3^{|B_x|}$ von Bag zu Bag variieren. 
\subsection{Implementierung der CountC-Prozedur}
\label{ssec:countc}
Da das dynamische Programm des Cut \& Count-Algorithmus die Berechnungsvorschrift für einen Bag rekursiv über den Bag des jeweiligen Kind-Knotens definiert, steigt der Algorithmus zu Beginn in $\mathbb{T}$ rekursiv ab bis er an einem Blattknoten angekommen ist. 
Für diesen gibt es keine Farb-Dimension (der Bag ist leer) und die $k \times kN$-Matrix wird initialisiert. 
Anschließend wird beim rekursiven Aufstieg für jeden Bag die entsprechende Berechnungsvorschrift angewendet und eine neue Datenmatrix berechnet. 

Im Falle eines \glqq Introduce Vertex\grqq -Bag werden für jede Färbung des Bags des Kindknotens drei neue Färbungen hinzugefügt.
Für einen \glqq Forget\grqq -Bag werden jeweils drei Färbungen des Bags des Kindknotens zu einer Färbung zusammengeführt.
Für alle anderen Bag-Typen bleibt die Länge der Farb-Dimension gleich, es werden jedoch nur Werte übernommen, welche die in Sektion \ref{sec:dynP} definierten Bedingungen erfüllen. 
Der \glqq Join\grqq -Bag nimmt eine Sonderstellung ein, da er als einziger zwei Kindknoten besitzt und im Algorithmus auf die Daten beider Bags zugreift. 
Die rekursive Berechnung in symmetrischer Reihenfolge gewährleistet, dass beide Kindknoten eines \glqq Join\grqq -Bags vorher berechnet werden. 
Der letzte Berechnungsschritt für den Wurzelknoten entspricht der Berechnung eines \glqq Forget\grqq -Knoten und führt die letzten drei Färbungen zusammen, so dass der Wurzelknoten (mit leerem Bag) eine $k \times kN$-Datenmatrix enthält. 
Diese kann für die Abfrage der Lösungen $A_r(k,W,\emptyset)$ genutzt werden.

Der Programmablauf ist in der Auflistung \ref{code:pseudo} dargestellt.

\begin{svgraybox}
\begin{lstlisting}[language=python,label={code:pseudo}, caption=Pseudocode für das dynamische Programm]
v1 = terminals[0]
def countC(node, indices, child_data, k, N, terminals, weights):
    if node.linker_Knoten is not None:
        # steige linksseitig ab
        child_data = countC(node.linker_Knoten, indices, child_data, k, N, terminals, weights)
    if node.rechter_Knoten is not None:
	# steige rechtsseitig ab
	child_data_right = countC(node.rechter_Knoten, indices, child_data, k, N, terminals, weights)
    if node.Bag_Typ == Leaf:
    	# erzeuge und initialisiere k x kN Datenmatrix
    	dm = new data[k, k*N]
    	dm[0,0] =  1
    	return dm
    elif node.Bag_Typ == Root:
	# v wurde aus Bag entfernt
	data = new data[3^node.bag.length, k, k*N]
	for i in range(0,k):
		for w in range(0,kN):
			data[s,i,w] = child_data[s=0,i,w] + child_data[s=1,i,w] + child_data[s=2,i,w]
	return data			
    elif node.Bag_Typ == Introduce_Edge:
	# im 'Introduce Edge'-Bag (u,v sind die Knoten der Kante e)
	# s ist die Faerbung
		data = data = new data[3^node.bag.length, k, k*N]
		for s in len(data):
			if( s(u) == 0 | s(v) == 0 | s(u) == s(v) ):
				for i in range(0,k):
					for w in range(0,kN):
						data[s,i,w] = child_data[s,i,w]
        return data
    elif node.Bag_Typ == Introduce_Vertex:
        # erzeuge neue Datenmatrix (groesser als Kind, da pro Knoten im Bag drei neue Faerbungen)
        # v ist der 'introduced vertex' 
        data = new data[3^(child_data.length + 1), k, k * N]
        
        for s in child_colorings:
        	# berechne Indices fuer neue Faerbungen
        	indices = calculate_new_indices
            for i in range(0, k):
                for w in range(0, k * N):
                    if not terminals.contains(v):
                        data[indices[0], i, w] = child_data[s, i, w]
                    data[indices[1], i, w] = child_data[s, i - 1, w - weights(v)]
                    if v != v1:
                        data[indices[2], i, w] = data[s, i - 1, w - weights.get(introduced_vertex)]
        return data
    elif node.Bag_Typ == Forget:
    	# v ist der 'forget vertex'
        data = new data[3^(child_data.length - 1), k, k * N]
		
        for s in colorings:
            for i in range(0, k):
                for w in range(0, k * N):
                    # berechne die drei Faerbungen, die aufsummiert werden
                    indices = calculate_indices()
                    data[s, i, w] = child_data[indices[0], i, w] +
                    		    child_data[indices[1], i, w] +
                                    child_data[indices[2], i, w]
        return data
    elif node.Bag_Typ == Join:
	data = new data[node.bag.length, k, k * N]
        for s in colorings:
            for i in range(0, k):
                for w in range(0, k * N):
                    colored_nodes = all_nodes_by_coloring(1,2)
                    bound_i = i + colored_nodes.length
                    bound_w = w + get_sum_of_weights(colored_nodes)
                    for i1 in range(0, bound_i):
                        for w1 in range(0, bound_w):
                            i2 = acc_bound_1 - i1
                            w2 = acc_bound_2 - w1
                            if w1 >= (k * N) or w2 >= (k * N) or i1 >= k or i2 >= k:
                                value += 0
                            else:
                                value += child_data[s, i1, w1] *   
                                         child_data_right[s, i2, w2])
                    data[s, i, w] = value
        return data
    return data

\end{lstlisting}
\end{svgraybox}

\subsection{Berechnung der Färbungen}
\label{ssec:colors}
Für die Kodierung der Färbungsdimension muss eine geeignete Zuordnung von Färbungen zu Indices der Datenmatrix eingeführt werden. Dafür benutzen wir eine ternäre Kodierung mit folgender Zuordnung:
\begin{center}
$0 \rightarrow s=0$\\
$1 \rightarrow s=1_1$\\
$2 \rightarrow s=1_2$\\
\end{center}
Für die Bagtypen \glqq Forget\grqq und \glqq Introduce Vertex\grqq werden Funktionen benötigt, welche fo
\section{Evaluierung}
\label{sec:eval}
Die Laufzeit des dynamischen Programms wurde anhand von Beispielen getestet. Zu sehen sind die Input-Parameter k und N sowie die Anzahl der Knoten des Graphen sowie die in der Nice-Tree-Decomposition erhaltene \textit{treewidth}.
\begin{table}
\centering
\begin{tabular}{l | l} 
\textbf{Input} & \textbf{ $\varnothing$ T in $s$}\\
\hline
(k=2, N= 6, |V|=3, tw(G)=2) & $ \sim 0.002$ \\
(k=3, N=14, |V|=7, tw(G)=3) & $ \sim 0.83$ \\
(k=4, N=32, |V|=16, tw(G)=5) & $ \sim 14.23$ \\
\end{tabular}
\end{table}

Es ist ersichtlich, dass der Algorithmus schon bei kleinen Graphenerweiterungen merkbare Laufzeitverlängerungen aufweist. Es ist anzunehmen, dass der Algorithmus in der Praxis nur eingeschränkt nutzbar ist. Praxisrelevante Probleme werden sich wahrscheinlich in Graphen repräsentieren, die weit aus komplexer sind, als die von uns getesteten Beispiele. Wir vermuten die Laufzeit wäre dort nichtmehr tragbar oder zumindest nicht effizient genug. Desweiteren ist der Speicherbedarf der Cut \& Count-Technik nicht außer acht zu lassen. Jeder Bag benötigt eine $3^t\times k\times kN$-Matrix. Bei größeren Graphen und hohem gewählten $N$, zur Verringerung des Falsch-Negativ Ergebnisses, kann diese schnell sehr groß werden.

\section{Ausblick}
\label{sec:outlook}

