\chapter{Implementierung}
\label{c:impl}

\section{Nice Tree Decomposition}
\label{sec:impl_ntd}
Es wurde ein Algorithmus entwickelt, der als Eingabe eine standardmäßige Nice Tree Decomposition $\mathbb{T}$ eines Graphen $G$ erhält und eine Nice Tree Decomposition (siehe Kapitel \ref{sec:impl_ntd}) ausgibt. 
Da der Fokus dieser Arbeit auf der Implementierung des dynamischen Programms des Cut \& Count-Algorithmus liegt, wurde der Algorithmus nicht hinsichtlich der in \cite{kloks1994} beschriebenen polynomiellen Laufzeit optimiert. 

Der Algorithmus iteriert mehrmals in symmetrischer Reihenfolge (ausgehend von der Wurzel linksseitig absteigend) über $\mathbb{T}$ und fügt dabei die fehlenden Knoten ein. 
Hierbei sollte erwähnt werden, dass die Implementierung mit Ausnahme des \glqq Join\grqq -Bags neue Knoten stets linksseitig an den Elternknoten angehängt werden. 
Dies ist für die rekursive Iteration in Sektion \ref{sec:impl_dynP} wichtig.

Zu Beginn werden am bisherigen Wurzelknoten so lange \glqq Forget\grqq -Knoten angehängt bis noch ein Knoten des Ursprungsgraphen im Bag verbleibt. Anschließend wird ein letzter Knoten mit leerem Bag als neuer Wurzelknoten hinzugefügt. 
Ähnlich wird hinsichtlich der Blattknoten verfahren. 
Entsprechend der Differenz eines leeren Bags und der Bags der bisherigen Blattknoten werden am Ende jedes Pfades neue \glqq Introduce-Vertex\grqq -Knoten und ein Knoten mit leerem Bag als neuer Blattknoten angehängt. 
Für bestehende \glqq Join\grqq -Knoten werden die Bags der beiden Kindknoten verglichen. 
Sofern sie nicht denselben Bag wie der \glqq Join\grqq -Knoten haben, werden neue Knoten (\glqq Forget\grqq , \glqq Introduce Vertex\grqq ) eingefügt, bis die Bags identisch mit dem Elternknoten sind. 
In der nächsten Iteration werden die Differenzen der Bags von Kind- und Elternknoten verglichen. 
Falls diese größer eins ist, werden entsprechend viele neue Knoten (\glqq Forget\grqq , \glqq Introduce Vertex\grqq ) eingeführt.
Zuletzt wird für jede Kante $e$ des Ursprungsgraphen $G$ über den Graphen iteriert. 
Beim ersten gemeinsamen Auftreten der Knoten der Kante $e$ innerhalb eines Bags, wird oberhalb des Knoten dieses Bags ein neuer \glqq Introduce Edge\grqq -Knoten eingeführt und mit den Knoten der Kante $e$ gekennzeichnet.

Nach diesen Modifikationen liegt der Graph in der Form einer Nice Tree Decomposition wie in Sektion \ref{sec:ntd_ntd} beschrieben vor und kann zur Berechnung des dynamischen Programms verwendet werden.

\section{Dynamisches Programm}
\label{sec:impl_dynP}
Die Berechnungsvorschrift des dynamischen Programms ist in Sektion \ref{c:cc_steiner} erläutert. 
Für die Implementierung wird vom Wurzelknoten ausgehend in symmetrischer Reihenfolge über die Nice Tree Decomposition $\mathbb{T}$ iteriert und für jeden Bag eine $k \times kN \times 3^{|B_x|}$ - Matrix berechnet, wobei die Größe der Lösung $k$ und $N$ als Inputparameter übergeben werden. 
Die erste Dimension $k$ beschreibt die Größe (Anzahl Knoten) der Lösungsmenge. 
Die zweite Dimension $kN$ steht für die Summe der Gewichte der Lösungsmenge. 
Obwohl die Gewichte zufällig einheitlich verteilt werden, kann im schlechtesten Fall jedem Knoten das Gewicht $N$ zugewiesen werden. 
$3^{|B_x|}$ beschreibt die Anzahl der möglichen Färbungen innerhalb eines Bags. 
Während $k,N$ festgelegt sind, kann die Länge der Farb-Dimension $3^{|B_x|}$ von Bag zu Bag variieren. 

Da das dynamische Programm des Cut \& Count-Algorithmus die Berechnungsvorschrift für einen Bag rekursiv über den Bag des jeweiligen Kind-Knotens definiert, steigt der Algorithmus zu Beginn in $\mathbb{T}$ rekursiv ab bis er an einem Blattknoten angekommen ist. 
Für diesen gibt es keine Farb-Dimension (der Bag ist leer) und die $k \times kN$-Matrix wird initialisiert. 
Anschließend wird beim rekursiven Aufstieg für jeden Bag die entsprechende Berechnungsvorschrift angewendet und eine neue Datenmatrix berechnet. 

Im Falle eines \glqq Introduce Vertex\grqq -Bag werden für jede Färbung des Bags des Kindknotens drei neue Färbungen hinzugefügt.
Für einen \glqq Forget\grqq -Bag werden jeweils drei Färbungen des Bags des Kindknotens zu einer Färbung zusammengeführt.
Für alle anderen Bag-Typen bleibt die Länge der Farb-Dimension gleich, es werden jedoch nur Werte übernommen, welche die in Sektion \ref{sec:dynP} definierten Bedingungen erfüllen. 
Der \glqq Join\grqq -Bag nimmt eine Sonderstellung ein, da er als einziger zwei Kindknoten besitzt und im Algorithmus auf die Daten beider Bags zugreift. 
Die rekursive Berechnung in symmetrischer Reihenfolge gewährleistet, dass beide Kindknoten eines \glqq Join\grqq -Bags vorher berechnet werden. 
Der letzte Berechnungsschritt für den Wurzelknoten entspricht der Berechnung eines \glqq Forget\grqq -Knoten und führt die letzten drei Färbungen zusammen, so dass der Wurzelknoten (mit leerem Bag) eine $k \times kN$-Datenmatrix enthält. 
Diese kann für die Abfrage der Lösungen $A_r(k,W,\emptyset)$ genutzt werden.
\section{Evaluierung}
\label{sec:eval}

\section{Ausblick}
\label{sec:outlook}
