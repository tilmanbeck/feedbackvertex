%%%%%%%%%%%%%%%%%%%%% chapter.tex %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% sample chapter
%
% Use this file as a template for your own input.
%
%%%%%%%%%%%%%%%%%%%%%%%% Springer-Verlag %%%%%%%%%%%%%%%%%%%%%%%%%%
%\motto{Use the template \emph{chapter.tex} to style the various elements of your chapter content.}
\chapter{Cut \& Count-Technik}
\label{c:cc_general} % Always give a unique label
% use \chaptermark{}
% to alter or adjust the chapter heading in the running head


\section{Einführendes}
\label{sec:1}
Die Cut \& Count-Technik wird benutzt um connectivity-type Probleme mithilfe von Randomisierung zu lösen. Dabei handelt es sich um Graphen-Probleme, bei denen zusammenhängende Submengen der Knoten gefunden werden müssen die problemspezifische  Eigenschaften erfüllen müssen. Beispiele hierfür sind Longest Path, Steiner Tree, Feedback Vertex Set, uvm.
Die Cut \& Count-Technik verlangt zur Lösung der Probleme eine Randomisierung der Lösungsmenge, da sie nur korrekt Funktioniert, wenn es eine oder keine Lösung gibt. Dies Bedeutet, dass alle Lösungskandidaten eine zufällig und unabhängig gewählte Eigenschaft bekommen, welche zusätzlich Anforderungen erfüllen muss, um als gültige Lösungsmenge zu gelten. Diese Isolation der Lösungsmenge wird durch das Isolations-Lemma beschrieben.

\section{Monte-Carlo-Algorithmus}
\label{sec:2}

Verwendet man die Cut \& Count-Technik um ein Algorithmus zur Lösung der connectivity-type Probleme zu entwerfen, enthält man einen Monte-Carlo-Algorithmus. Dies bedeutet, dass der hervorgegangene Algorithmus niemals ein false-positiv \footnote{Der Algorithmus gibt eine positive Antwort auf das Problem, obwohl keine Lösung existiert} ausgeben kann aber zu einer gewissen Wahrscheinlichkeit ein false-negativ \footnote{Der Algorithmus gibt eine negative Antwort auf das Problem, obwohl eine Lösung existiert.}. Die Wahrscheinlichkeit eines false-negativ wird durch das Isolations-Lemma bestimmt. Da eine Ausgabe eine false-negativ einer bestimmten Wahrscheinlichkeit unterliegt ist es ratsam Monte-Carlo-Algorithmen mehrmals hintereinander auszuführen. Es begünstigt die Wahrscheinlichkeit eine Lösungsmenge zu finden.

Der hervorgegangene Monte-Carlo-Algorithmus kann bei gegebener Tree-Decomposition mit Braumbreite $t$ eines ungerichteten Graphens Lösungen bestimmen bei folgenden Probleme und Laufzeiten:
\begin{itemize}
\item Steiner Tree in $3^t |V|^{O(1)}$
\item FeedBack Vertex Set in $3^t|V|^{O(1)}$
\item ...
\end{itemize}

\section{Isolation Lemma}
\label{sec:test}

Wie zuvor erwähnt ist die Cut \& Count-Technik nur dann korrekt, wenn eine oder keine Lösung existiert. Da es bei vielen der connectivity-type Probleme sehr  wahrscheinlich ist, dass mehrere Lösungen existieren, muss die Lösungsmenge reduziert werden. Dafür wird auf das Isolations-Lemma zurück gegriffen. Es ist wie folgt definiert:

A function $\omega : U \rightarrow \mathbb{Z}$ isolates a set family $\mathcal{F} \subseteq 2^U$ if there is a unique $S' \in \mathcal{F}$ with $\omega (S')=min_{S \in \mathcal{S}} \omega(S)$\\

Im Paper wird es im Lemma 2.5 verwendet, um etwas über die Wahrscheinlichkeit der Isolation auszusagen:\\
\\Let $\mathcal{F} \subseteq 2^U$ be a set family over a universe $U$ with $|\mathcal{F}| > 0$. For each $u \in U$ ,
choose a weight $\omega(u) \in {1, 2, . . . , N }$ uniformly and independently at random. Then
\begin{center}
$prob[\omega$ isolates $\mathcal{F}]\geq 1 - \frac{|U|}{N}$
\end{center}

Durch die Wahl eines großen $N$ kann somit die Wahrscheinlichkeit eines false-negativ stark reduziert werden aber es wird zugleich auch die Laufzeit des Algorithmus erhöht.